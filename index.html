<!DOCTYPE html>

<html lang="en">
<head>
<title>Threads!</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<link href="css/main.css" rel="stylesheet">
</head>

<body>

</body>

<!--
  three.js 3d library
  -->
<script src="js/three.min.js"></script>

<!--
  VRControls.js acquires positional information from connected VR devices and applies the transformations to a three.js camera object.
   -->
<script src="js/VRControls.js"></script>

<!--
  VREffect.js handles stereo camera setup and rendering.
  -->
<script src="js/VREffect.js"></script>

<!--
  A polyfill for WebVR using the Device{Motion,Orientation}Event API.
  -->
<script src="js/webvr-polyfill.js"></script>

<!--
  Helps enter and exit VR mode, provides best practices while in VR.
  -->
<script src="js/webvr-manager.js"></script>

<!-- 
  Threads library
  --> 

<!-- <script src="js/threads.js"></script>
 -->
<script>
//Setup three.js WebGL renderer
var renderer = new THREE.WebGLRenderer({ antialias: true });

// Append the canvas element created by the renderer to document body element.
document.body.appendChild(renderer.domElement);

// Create a three.js scene
var scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x000000, 0, 10000);

// Create a three.js camera
var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);

// Apply VR headset positional data to camera.
var controls = new THREE.VRControls(camera);

// Apply VR stereo rendering to renderer
var effect = new THREE.VREffect(renderer);
effect.setSize(window.innerWidth, window.innerHeight);

// Create a VR manager helper to enter and exit VR mode.
var vrmgr = new WebVRManager(effect);

// Create 3d objects
var geometry = new THREE.BoxGeometry(10, 10, 10);

// var geometry = new THREE.PlaneBufferGeometry( -20, -10, 10, 10);
var material = new THREE.MeshBasicMaterial( {color: 0xff0000, side: THREE.DoubleSide} );
var line = new THREE.Mesh(geometry, material);
line.position.x = 0;
line.position.y = 0;
line.position.z = -20;
line.rotation.x = -90*Math.PI/180;
// geometry.vertices.push(new THREE.Vector3(-10,0,0));
// geometry.vertices.push(new THREE.Vector3(0, 10,0));
// geometry.vertices.push(new THREE.Vector3(10, 0,0));
// var cube = new THREE.Mesh(geometry, material);

// Position cube mesh
// cube.position.z = -20;

// Add cube mesh to your three.js scene
// scene.add(cube);
scene.add(line);

// Request animation frame loop function
function animate() {
  // Apply rotation to cube mesh
  // cube.rotation.y += 0.01;

  line.rotation.y += 0.01;

  // Update VR headset position and apply to camera.
  controls.update();

  // Render the scene through the VREffect, but only if it's in VR mode.
  if (vrmgr.isVRMode()) {
    effect.render(scene, camera);
  } else {
    renderer.render(scene, camera);
  }

  requestAnimationFrame( animate );
}

// Kick off animation loop
animate();

// Listen for keyboard event and zero positional sensor on appropriate keypress.
function onKey(event) {
  if (event.keyCode == 90) { // z
    controls.zeroSensor();
  }

  // Key codes can be found here:
  // https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode
  // 37 = left
  // 39 = right
  // 38 = up
  // 40 = down

  if (event.keyCode == 74) { // "J"
    line.position.x = line.position.x - 1;
  }
  if (event.keyCode == 76) { // "L"
    line.position.x = line.position.x + 1;
  }

  if (event.keyCode == 73) { // "I"
    line.position.z = line.position.z - 1;
  }
  if (event.keyCode == 75) { // "K"
    line.position.z = line.position.z + 1;
  }

};

window.addEventListener('keydown', onKey, true);


// Handle window resizes
function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();

  effect.setSize( window.innerWidth, window.innerHeight );
}

window.addEventListener('resize', onWindowResize, false);

</script>
</html>
